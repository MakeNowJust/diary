{"componentChunkName":"component---src-templates-post-js","path":"/post/2021-01-31-diary/","result":{"data":{"site":{"siteMetadata":{"title":"℘ make now just"}},"markdownRemark":{"html":"<h1>やったこと</h1>\n<h2>シャニ</h2>\n<p>黒セーラの灯織のTrue。<br>\nSランクで親愛Maxなのでいい感じなのでは。<br>\nコミュも良かった。</p>\n<p><a href=\"https://twitter.com/make_now_just/status/1355550860583993351\" class=\"embedly-card\">https://twitter.com/make_now_just/status/1355550860583993351</a></p>\n<p>あとフェスイベントを終わらせた。<br>\n最近シャニをやる時間がない。</p>\n<h2>minicheck</h2>\n<p>色々考えたら思い付いてしまった。<br>\n天才かもしれない。</p>\n<p><span class=\"math math-inline\">R</span> を乱数生成器として、<span class=\"math math-inline\">g_A : R \\to (R \\times A)</span> を型 <span class=\"math math-inline\">A</span> の値を生成する生成器オブジェクトとする。<br>\n<span class=\"math math-inline\">a \\in A</span> について <span class=\"math math-inline\">g_A(r) = (r', a)</span> となる <span class=\"math math-inline\">r \\in R</span> が存在するとき、<span class=\"math math-inline\">g_A</span> は <span class=\"math math-inline\">a</span> を<strong>生成可能</strong>といって<span class=\"math math-inline\">a \\mathrel{\\tilde\\in} g_A</span> で表す。<br>\nこのとき任意の <span class=\"math math-inline\">a \\in A</span> について <span class=\"math math-inline\">a \\mathrel{\\tilde\\in} g_A</span> のとき <span class=\"math math-inline\">g_A</span> は<strong>網羅的</strong>である、という。<br>\n当然だが、生成器オブジェクトは網羅的であることが望ましい。</p>\n<p><span class=\"math math-inline\">c_A : \\forall B.\\ (R \\to (R \\times B)) \\to (R \\to (R \\times (A \\mathrel{\\tilde\\to} B)))</span> を <span class=\"math math-inline\">A</span> に対するco-生成器オブジェクトとする。<br>\nただし <span class=\"math math-inline\">A \\mathrel{\\tilde\\to} B</span> は <span class=\"math math-inline\">A</span> から <span class=\"math math-inline\">B</span> への部分関数を表すデータ構造の全体からなる集合とする。<br>\n<span class=\"math math-inline\">c_A</span> と <span class=\"math math-inline\">g_B</span> があるとき、<span class=\"math math-inline\">A</span> から <span class=\"math math-inline\">B</span> への関数を生成する生成器オブジェクト <span class=\"math math-inline\">g_{\\to}(c_A, g_B)</span> を構成できる。</p>\n<p><span class=\"math math-inline\">g_A</span> について <span class=\"math math-inline\">g_{\\ast}(g_A) : R \\to (R \\times A^\\ast)</span> を <span class=\"math math-inline\">A</span> の値の列 (リスト) を生成する生成器オブジェクト、<br>\n<span class=\"math math-inline\">c_A</span> について <span class=\"math math-inline\">c_{\\ast}(c_A) : \\forall B.\\ (R \\to (R \\times B)) \\to (R \\to (R \\times (A^\\ast \\mathrel{\\tilde\\to} B)))</span> を <span class=\"math math-inline\">A</span> の値の列に対するco-生成器オブジェクトとする。</p>\n<p><span class=\"math math-inline\">g_A</span> と <span class=\"math math-inline\">c_B</span> が与えられたときに、<br>\n<span class=\"math math-inline\">c_{\\to}(g_A, c_B) : \\forall C.\\ (R \\to (R \\times C)) \\to (R \\to (R \\times ((A \\to B) \\mathrel{\\tilde\\to} C)))</span> を構成できるだろうか？<br>\n考えられる1つの方法として、次のHaskell風の疑似コードで説明されるようなものがある。</p>\n<div class=\"math math-display\">\\begin{aligned}\nc_{\\to}\\ (g_A,&#x26;c_B)(g_C)(r_0) = \\\\\n\\mathrm{let}\\ &#x26;(r_1, a) = g_A(r_0) \\\\\n             &#x26;(r_2, f_1) = g_{\\to}(c_B, g_C)(r_1) \\\\\n\\mathrm{in}\\ &#x26;(r_2, \\lambda\\ f_2 \\mapsto f_1(f_2(a)))\n\\end{aligned}</div>\n<p>つまり、<span class=\"math math-inline\">A</span> の値と <span class=\"math math-inline\">B \\to C</span> の関数を生成しておいて、渡ってきた <span class=\"math math-inline\">A \\to B</span> の関数に <span class=\"math math-inline\">A</span> の値を、その返り値を <span class=\"math math-inline\">B \\to C</span> の関数に渡すことで、最終的に <span class=\"math math-inline\">C</span> の返している。</p>\n<p>これは一見上手く動作しそうだが、実際には網羅的ではないという問題がある。<br>\n具体的には、この方法では <span class=\"math math-inline\">A \\times C^B</span> 種類の値しか生成できないが、 <span class=\"math math-inline\">(A \\to B) \\to C</span> の値の種類は <span class=\"math math-inline\">C^{B^A}</span> 程度あるので、必然的に漏れが存在することになるわけである。</p>\n<p>ここで1つの事実を確認する。</p>\n<blockquote>\n<p><span class=\"math math-inline\">B^\\ast</span> には <span class=\"math math-inline\">A \\to B</span> と同型となる部分が存在する。</p>\n</blockquote>\n<p>つまり <span class=\"math math-inline\">A = \\{ a_1, a_2, \\cdots \\}</span> とおいたとき、 <span class=\"math math-inline\">f : A \\to B</span> があれば <span class=\"math math-inline\">[f(a_1), f(a_2), \\cdots]</span> として <span class=\"math math-inline\">B^\\ast</span> の元が得られて、反対に <span class=\"math math-inline\">[b_1, b_2, \\cdots]</span> があるとき <span class=\"math math-inline\">f(a_k) = b_k</span> として <span class=\"math math-inline\">f</span> を構成できる。</p>\n<p>よって <span class=\"math math-inline\">B^\\ast \\to C</span> は <span class=\"math math-inline\">(A \\to B) \\to C</span> よりも真に大きい。<br>\nこれを利用して、次のような疑似コードで説明する方法を考える。</p>\n<div class=\"math math-display\">\\begin{aligned}\nc_{\\to}\\ (g_A,&#x26;c_B)(g_C)(r_0) = \\\\\n\\mathrm{let}\\ &#x26;(r_1, s) = g_{\\ast}(g_A)(r_0) \\\\\n             &#x26;(r_2, f_1) = g_{\\to}(c_{\\ast}(c_B), g_C)(r_1) \\\\\n\\mathrm{in}\\ &#x26;(r_2, \\lambda\\ f_2 \\mapsto f_1(\\mathrm{map}(f_2, s)))\n\\end{aligned}</div>\n<p>つまり、 <span class=\"math math-inline\">A</span> の値の列と <span class=\"math math-inline\">B^\\ast \\to C</span> の関数を生成しておいて、渡ってきた <span class=\"math math-inline\">A \\to B</span> の関数に <span class=\"math math-inline\">A</span> の列の各値を適用して、その返り値の列を <span class=\"math math-inline\">B^\\ast \\to C</span> の関数に渡すことで、最終的に <span class=\"math math-inline\">C</span> の値を得ている。</p>\n<p>この方法ならば、各生成器オブジェクトやco-生成器オブジェクトが網羅的に機能していれば、こちらも網羅的となる。<br>\nしかし、列の生成器オブジェクトは重複する値を持つ列を生成する可能性があるが、そのようなものはこの場合では無駄である。<br>\nそこで、次の値の重複しない <span class=\"math math-inline\">A</span> の列を生成する生成器オブジェクト <span class=\"math math-inline\">g_{\\le}(g_A)</span> を <span class=\"math math-inline\">g_{\\ast}(g_A)</span> の代わりに用いれば良いのではないかと思われる。</p>\n<div class=\"math math-display\">\\begin{aligned}\ng_{\\le}(g_A)\\ = f([]) &#x26;\\\\\n\\mathrm{where}\\ f(s)(r_0) &#x26;= \\mathrm{let}\\ (r_1, a) = g_A(r_0)\\ \\mathrm{in}\\\\\n\\mathrm{if}\\ a \\in s &#x26;\\ \\mathrm{then}\\ s\\ \\mathrm{else}\\ f(s \\cdot [a])(r_1)\n\\end{aligned}</div>\n<p>というのが今のところの考察となる。<br>\nかなり良く考えられているのではないかと思う。<br>\n単一の値の代わりに列や集合を渡す、というのはわりと思い付くアイディアかもしれないけれど、それをちゃんと意味付けできたことに意義がある。</p>\n<p>が、いくつかあやしいところもあって、例えば「<span class=\"math math-inline\">B^\\ast</span> には <span class=\"math math-inline\">A \\to B</span> と同型となる部分が存在する」というのは <span class=\"math math-inline\">A</span> が有限集合じゃない場合かなり嘘っぽい。<br>\nまあ無限リストが許されるなら可算集合でもいけると思うけど、非可算な場合はどうすればいいのか検討もつかない。<br>\nとはいえ、コンピュータで表現できるデータが非可算になったりするのかもよく分からないので何とも言えない、という感じ。</p>\n<p>どうにか昇華した感じがする。楽しいね。</p>","fields":{"date":"2021-01-31"},"frontmatter":{"title":"minicheckやっていき"},"excerpt":"やったこと シャニ 黒セーラの灯織のTrue。 Sランクで親愛Maxなのでいい感じなのでは。 コミュも良かった。 https://twitter.com/make_now_just/status/1355550860583993351 あとフェスイベントを終わらせた。 最近シャ…"},"prev":{"fields":{"date":"2021-02-01","slug":"/post/2021-02-01-diary/"},"frontmatter":{"title":"recheckにした"}},"next":{"fields":{"date":"2021-01-30","slug":"/post/2021-01-30-diary/"},"frontmatter":{"title":"Weekly Crystal-JPをやった"}}},"pageContext":{"slug":"/post/2021-01-31-diary/","prevSlug":"/post/2021-02-01-diary/","nextSlug":"/post/2021-01-30-diary/"}},"staticQueryHashes":["530032413"]}