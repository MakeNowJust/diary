{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/post/2019-08-05-diary/",
    "result": {"data":{"site":{"siteMetadata":{"title":"℘ make now just"}},"markdownRemark":{"html":"<h1>やったこと</h1>\n<h2>マギレコ</h2>\n<p>昨日イベントアイテム集めすぎて周回が面倒。<br>\nなんで1万近く集めてるんですかね‥‥。</p>\n<h2>Scala</h2>\n<p>内側の関手が<code>Monad</code>かつ<code>Alternative</code>のとき<code>StateT</code>に<code>Alternative</code>のインスタンスを提供しているのだけど、これが内側の関手によっては<code>Alternative</code>のlawを満たさないことがあることに気付いた。</p>\n<p>具体的には<code>StateT[Option, Any, *]</code>の<code>Alternative</code>インスタンスはright distibutive lawを満たさない。<br>\nright distributive lawというのは<code>(ff &#x3C;+> fg) &#x3C;*> fa === (ff &#x3C;*> fa) &#x3C;+> (fg &#x3C;*> fa)</code>というやつで、満たさない例はこんなものがある。</p>\n<pre><code class=\"hljs language-scala\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">guard</span></span>[<span class=\"hljs-type\">F</span>[_]: <span class=\"hljs-type\">Alternative</span>](c: <span class=\"hljs-type\">Boolean</span>): <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">Unit</span>] =\n  <span class=\"hljs-keyword\">if</span> (c) <span class=\"hljs-type\">Alternative</span>[<span class=\"hljs-type\">F</span>].pure(()) <span class=\"hljs-keyword\">else</span> <span class=\"hljs-type\">Alternative</span>[<span class=\"hljs-type\">F</span>].emptyK\n\n<span class=\"hljs-keyword\">val</span> fa: <span class=\"hljs-type\">StateT</span>[<span class=\"hljs-type\">Option</span>, <span class=\"hljs-type\">Boolean</span>, <span class=\"hljs-type\">Unit</span>] =\n  <span class=\"hljs-type\">StateT</span>.get.flatMap(guard(_))\n<span class=\"hljs-keyword\">val</span> ff: <span class=\"hljs-type\">StateT</span>[<span class=\"hljs-type\">Option</span>, <span class=\"hljs-type\">Boolean</span>, <span class=\"hljs-type\">Unit</span> => <span class=\"hljs-type\">Unit</span>] =\n  <span class=\"hljs-type\">StateT</span>.put(<span class=\"hljs-literal\">false</span>).map(_ => x => x)\n<span class=\"hljs-keyword\">val</span> fg: <span class=\"hljs-type\">StateT</span>[<span class=\"hljs-type\">Option</span>, <span class=\"hljs-type\">Boolean</span>, <span class=\"hljs-type\">Unit</span> => <span class=\"hljs-type\">Unit</span>] =\n  <span class=\"hljs-type\">StateT</span>.put(<span class=\"hljs-literal\">true</span>).map(_ => x => x)</code></pre>\n<p>つまり、</p>\n<ul>\n<li><code>ff</code>は状態を<code>false</code>セットして関数を返す<code>StateT</code>オブジェクト</li>\n<li><code>fg</code>は状態を<code>true</code>にセットして関数を返す<code>StateT</code>オブジェクト</li>\n<li><code>fa</code>は状態が<code>true</code>のとき<code>()</code>を返し、<code>falsde</code>のときは失敗する<code>StateT</code>オブジェクト</li>\n</ul>\n<p>このとき<code>(ff &#x3C;+> fg) &#x3C;*> fa</code>を適当に実行すると<code>None</code>になるが、<code>(ff &#x3C;*> fa) &#x3C;+> (fg &#x3C;*> fa)</code>は<code>Some((true, ()))</code>になり、一致しない。</p>\n<p>どうしてこうなるのかというと、</p>\n<ul>\n<li>左辺では<code>(ff &#x3C;+> fg)</code>が<code>ff</code>の結果になり、その後<code>fa</code>が計算されるが、<code>ff</code>では状態が<code>false</code>になっているため<code>None</code>になり</li>\n<li>右辺では<code>(ff &#x3C;*> fa)</code>が<code>None</code>になったあと<code>(fg &#x3C;*> fa)</code>が計算されて<code>Some((true, ()))</code>になるため。</li>\n</ul>\n<p>で、根本的な問題は<code>Option</code>が値を0か1つか持てず、バックトラックの余地が無いところかな、と考えている。<br>\nなので、仮に<code>Either[A, *]</code>とか<code>Try[E, *]</code>に<code>Alternative</code>のインスタンスがあったら同じような問題が起こると思う。</p>\n<p>ただ、具体的に内側の関手がどういうときにこの問題が起きるのかを表すようなlawは知られてないっぽいし(少なくとも<code>Option</code>の<code>Alternative</code>はright distributiveを満たしてるけど、<code>StateT</code>に入れるとこの問題が起きる)、<code>StateT</code>と同じような問題のあるモナド変換子があるのかもよく分からない。</p>\n<p>なので、この問題への対処は、</p>\n<ol>\n<li><code>StateT</code>の<code>Alternative</code>インスタンスを削除する</li>\n<li><code>Alternative</code>のlawからright disributiveを除く</li>\n</ol>\n<p>の2つくらいしか無いのではないかと思う。</p>\n<p>個人的には2.が悪くない気がしている。<br>\nright distributiveを諦めると<code>StateT</code>だけでなくて、<code>IO</code>とか<code>Parser</code>(Parsecのやつ)みたいなのも<code>Alternative</code>として合法になるし、実際その方が有意義だと思うので。</p>\n<p>catsの方で聞いてみたいけど英語かったるいなぁ。</p>\n<p>参考文献:  \"From monoids to near-semirings: the essence of MonadPlus and Alternative\" <a href=\"https://lirias.kuleuven.be/bitstream/123456789/499951/1/main.pdf\">https://lirias.kuleuven.be/bitstream/123456789/499951/1/main.pdf</a></p>","fields":{"date":"2019-08-05"},"frontmatter":{"title":"StateTのAlternativeインスタンスなんも分からん"},"excerpt":"やったこと マギレコ 昨日イベントアイテム集めすぎて周回が面倒。 なんで1万近く集めてるんですかね‥‥。 Scala 内側の関手がMonadかつAlternativeのときStateTにAlternativeのインスタンスを提供しているのだけど、これが内側の関手によってはAlt…"},"prev":{"fields":{"date":"2019-08-06","slug":"/post/2019-08-06-diary/"},"frontmatter":{"title":"Scala書いてた"}},"next":{"fields":{"date":"2019-08-04","slug":"/post/2019-08-04-diary/"},"frontmatter":{"title":"マギレコしてた"}}},"pageContext":{"slug":"/post/2019-08-05-diary/","prevSlug":"/post/2019-08-06-diary/","nextSlug":"/post/2019-08-04-diary/"}},
    "staticQueryHashes": ["530032413"]}