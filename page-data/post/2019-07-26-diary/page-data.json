{"componentChunkName":"component---src-templates-post-js","path":"/post/2019-07-26-diary/","webpackCompilationHash":"bdc33349dc7f69c722ef","result":{"data":{"site":{"siteMetadata":{"title":"℘ make now just"}},"markdownRemark":{"html":"<h1>やったこと</h1>\n<h2>ミリシタ</h2>\n<p>折り返し。早いなと思ったら一日短いらしい。</p>\n<p>とりあえず10万ptまで稼いだけど、うーん。</p>\n<h2>Scala関連</h2>\n<h3>型クラスの制約のエンコード方法について</h3>\n<p>ScalaでHaskellの型クラスの制約(<code>Eq a => Ord a</code>みたいなの)を表現するときに、Scalaでは2つの方法がある。</p>\n<p>1つは継承を用いるもので、<code>trait Ord[A] extends Eq[A]</code>のようにする。<br>\n基本的にはこちらが一般的で、ほとんどの場合はこちらを利用する。</p>\n<p>もう1つはメンバに制約の型クラスのインスタンスを持たせるもの。<br>\nこのようになる。</p>\n<pre><code class=\"hljs language-scala\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Ord</span>[<span class=\"hljs-type\">A</span>] </span>{\n  <span class=\"hljs-keyword\">val</span> eq: <span class=\"hljs-type\">Eq</span>[<span class=\"hljs-type\">A</span>]\n}</code></pre>\n<p>これはcatsの<code>Parallel</code>のように、そもそも継承として表せない場合や、<br>\n(これを<code>trait Parallel[F[_], G[_]] extends Applicative[F] with Monad[G]</code>とすると<code>F</code>に対する<code>map</code>と<code>G</code>に対する<code>map</code>が衝突したりしてロクなことにならない)</p>\n<pre><code class=\"hljs language-scala\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Parallel</span>[<span class=\"hljs-type\">F</span>[_], <span class=\"hljs-title\">G</span>[_]] </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">applicative</span></span>: <span class=\"hljs-type\">Applicative</span>[<span class=\"hljs-type\">F</span>]\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">monad</span></span>: <span class=\"hljs-type\">Monad</span>[<span class=\"hljs-type\">G</span>]\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">sequence</span></span>: <span class=\"hljs-type\">F</span> ~> <span class=\"hljs-type\">G</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">parallel</span></span>: <span class=\"hljs-type\">G</span> ~> <span class=\"hljs-type\">F</span>\n}</code></pre>\n<p>或いは継承関係が複数に枝分かれしていて、<code>implicit</code>が曖昧になる場合に使われる。</p>\n<h4><code>implicit</code>が曖昧になる場合</h4>\n<p>例えば<code>Functor</code>であることを制約に持つ型クラスとして<code>Applicative</code>と<code>Traverse</code>がある。<br>\nこれを単純に継承で表すとどのようなことが起こるだろうか。</p>\n<pre><code class=\"hljs language-scala\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Functor</span>[<span class=\"hljs-type\">F</span>[_]] </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">map</span></span>[<span class=\"hljs-type\">A</span>. <span class=\"hljs-type\">B</span>](fa: <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">A</span>], f: <span class=\"hljs-type\">A</span> => <span class=\"hljs-type\">B</span>): <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">B</span>]\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Applicative</span>[<span class=\"hljs-type\">F</span>[_]] <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Functor</span>[<span class=\"hljs-type\">F</span>] </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">ap</span></span>[<span class=\"hljs-type\">A</span>, <span class=\"hljs-type\">B</span>](ff: <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">A</span> => <span class=\"hljs-type\">B</span>])(fa: <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">A</span>]): <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">B</span>]\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">pure</span></span>[<span class=\"hljs-type\">A</span>](a: <span class=\"hljs-type\">A</span>): <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">A</span>]\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Foldable</span>[<span class=\"hljs-type\">F</span>[_]] </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foldLeft</span></span>[<span class=\"hljs-type\">A</span>, <span class=\"hljs-type\">B</span>](fa: <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">A</span>], b: <span class=\"hljs-type\">B</span>)(f: (<span class=\"hljs-type\">B</span>, <span class=\"hljs-type\">A</span>) => <span class=\"hljs-type\">B</span>): <span class=\"hljs-type\">B</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foldRight</span></span>[<span class=\"hljs-type\">A</span>, <span class=\"hljs-type\">B</span>](fa: <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">A</span>], b: <span class=\"hljs-type\">B</span>)(f: (<span class=\"hljs-type\">A</span>, <span class=\"hljs-type\">B</span>) => <span class=\"hljs-type\">B</span>): <span class=\"hljs-type\">B</span>\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Traverse</span>[<span class=\"hljs-type\">F</span>[_]] <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Foldable</span>[<span class=\"hljs-type\">F</span>] <span class=\"hljs-keyword\">with</span> <span class=\"hljs-title\">Functor</span>[<span class=\"hljs-type\">F</span>] </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">traverse</span></span>[<span class=\"hljs-type\">G</span>[_]: <span class=\"hljs-type\">Applicative</span>, <span class=\"hljs-type\">A</span>, <span class=\"hljs-type\">B</span>](fa: <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">A</span>])(f: <span class=\"hljs-type\">A</span> => <span class=\"hljs-type\">G</span>[<span class=\"hljs-type\">B</span>]): <span class=\"hljs-type\">G</span>[<span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">B</span>]]\n}</code></pre>\n<p>ここで<code>Applicative</code>かつ<code>Traverse</code>な型に対してはたらくようなメソッドで、<code>Functor</code>のメソッドである<code>map</code>を呼ぶようなものを考える。</p>\n<pre><code class=\"hljs language-scala\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foo</span></span>[<span class=\"hljs-type\">F</span>[_]: <span class=\"hljs-type\">Applicative</span>: <span class=\"hljs-type\">Traverse</span>, <span class=\"hljs-type\">A</span>, <span class=\"hljs-type\">B</span>](fa: <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">A</span>]) = implicitly[<span class=\"hljs-type\">Functor</span>[<span class=\"hljs-type\">F</span>]].map(fa)(a => ???)</code></pre>\n<p>これはコンパイルが通らない。<br>\nなぜならば<code>Functor</code>の<code>implicit</code>の候補が<code>Applicative</code>のものと<code>Traverse</code>のもので2つあり、曖昧になっているからだ。</p>\n<p>これは、次のように<code>functor</code>をメンバにして、<code>Functor</code>を取り出す用の<code>implicit def</code>を継承を使って優先順位を調整して定義すると良い。</p>\n<pre><code class=\"hljs language-scala\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Functor</span>[<span class=\"hljs-type\">F</span>[_]] </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">map</span></span>[<span class=\"hljs-type\">A</span>, <span class=\"hljs-type\">B</span>](fa: <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">A</span>])(f: <span class=\"hljs-type\">A</span> => <span class=\"hljs-type\">B</span>): <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">B</span>]\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Applicative</span>[<span class=\"hljs-type\">F</span>[_]] </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">functor</span></span>: <span class=\"hljs-type\">Functor</span>[<span class=\"hljs-type\">F</span>]\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">ap</span></span>[<span class=\"hljs-type\">A</span>, <span class=\"hljs-type\">B</span>](ff: <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">A</span> => <span class=\"hljs-type\">B</span>])(fa: <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">A</span>]): <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">B</span>]\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">pure</span></span>[<span class=\"hljs-type\">A</span>](a: <span class=\"hljs-type\">A</span>): <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">A</span>]\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Foldable</span>[<span class=\"hljs-type\">F</span>[_]] </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foldLeft</span></span>[<span class=\"hljs-type\">A</span>, <span class=\"hljs-type\">B</span>](fa: <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">A</span>], b: <span class=\"hljs-type\">B</span>)(f: (<span class=\"hljs-type\">B</span>, <span class=\"hljs-type\">A</span>) => <span class=\"hljs-type\">B</span>): <span class=\"hljs-type\">B</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foldRight</span></span>[<span class=\"hljs-type\">A</span>, <span class=\"hljs-type\">B</span>](fa: <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">A</span>], b: <span class=\"hljs-type\">B</span>)(f: (<span class=\"hljs-type\">A</span>, <span class=\"hljs-type\">B</span>) => <span class=\"hljs-type\">B</span>): <span class=\"hljs-type\">B</span>\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Traverse</span>[<span class=\"hljs-type\">F</span>[_]] </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">functor</span></span>: <span class=\"hljs-type\">Functor</span>[<span class=\"hljs-type\">F</span>]\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">foldable</span></span>: <span class=\"hljs-type\">Foldable</span>[<span class=\"hljs-type\">F</span>]\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">traverse</span></span>[<span class=\"hljs-type\">G</span>[_]: <span class=\"hljs-type\">Applicative</span>, <span class=\"hljs-type\">A</span>, <span class=\"hljs-type\">B</span>](fa: <span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">A</span>])(f: <span class=\"hljs-type\">A</span> => <span class=\"hljs-type\">G</span>[<span class=\"hljs-type\">B</span>]): <span class=\"hljs-type\">G</span>[<span class=\"hljs-type\">F</span>[<span class=\"hljs-type\">B</span>]]\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">Extract</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ExtractFunctor</span> <span class=\"hljs-keyword\">with</span> <span class=\"hljs-title\">ExtractFoldable</span></span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">ExtractFunctor</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ExtractFunctor0</span></span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">ExtractFunctor0</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ExtractFunctor1</span> </span>{\n  <span class=\"hljs-keyword\">implicit</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">extractFunctorFromApplicative</span></span>[<span class=\"hljs-type\">F</span>[_]: <span class=\"hljs-type\">Applicative</span>]: <span class=\"hljs-type\">Functor</span>[<span class=\"hljs-type\">F</span>] = <span class=\"hljs-type\">Applicative</span>[<span class=\"hljs-type\">F</span>].functor\n}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">ExtractFunctor1</span> </span>{\n  <span class=\"hljs-keyword\">implicit</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">extractFunctorFromTraverse</span></span>[<span class=\"hljs-type\">F</span>[_]: <span class=\"hljs-type\">Traverse</span>]: <span class=\"hljs-type\">Functor</span>[<span class=\"hljs-type\">F</span>] = <span class=\"hljs-type\">Traverse</span>[<span class=\"hljs-type\">F</span>].functor\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title\">ExtractFoldable</span> </span>{\n  <span class=\"hljs-keyword\">implicit</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">extractFoldableFromTraverse</span></span>[<span class=\"hljs-type\">F</span>[_]: <span class=\"hljs-type\">Traverse</span>]: <span class=\"hljs-type\">Foldable</span>[<span class=\"hljs-type\">F</span>] = <span class=\"hljs-type\">Traverse</span>[<span class=\"hljs-type\">F</span>].foldable\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">object</span> <span class=\"hljs-title\">extract</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Extract</span></span>\n\n<span class=\"hljs-keyword\">import</span> extract._</code></pre>\n<p>これでひとまず問題は解決する。</p>\n<h4>さらなる話題</h4>\n<p>‥‥という話がこの辺に書かれている。</p>\n<ul>\n<li>Typelevel.scala | Subtype type classes don't work:<br>\n<a href=\"https://typelevel.org/blog/2016/09/30/subtype-typeclasses.html\">https://typelevel.org/blog/2016/09/30/subtype-typeclasses.html</a></li>\n<li>The Limitations of Type Classes as Subtyped Implicits<br>\n(Short Paper): <a href=\"https://adelbertc.github.io/publications/typeclasses-scala17.pdf\">https://adelbertc.github.io/publications/typeclasses-scala17.pdf</a></li>\n</ul>\n<p>書いたのは同じ人で、下のPDFが上のやつの更新版、という感じ。</p>\n<p>とはいえこのメンバにする方法(MTL encodingとかinheritance free encodingとかいう)も万能ではなくて、欠点として、</p>\n<ul>\n<li>まず見るからに記述量が増える。正直しんどい。</li>\n<li>取り出す部分が拡張に対して開いていない。<br>\n例えば別のライブラリで<code>FunctorFilter</code>が定義されたとして、それから<code>Functor</code>を取り出す<code>implicit def</code>をどうやって衝突しないように定義できるだろうか？</li>\n</ul>\n<p>などの問題が挙げられる。</p>\n<p>そんなこんなな理由からcatsでは基本的には継承を使い、いくつかの衝突しがちな型クラスではメンバに埋め込む方法を取っているらしい。</p>\n<p><a href=\"https://typelevel.org/cats-mtl/getting-started.html\">cats-mtlのGetting Started</a>にもこんなことが書いてあった。</p>\n<blockquote>\n<p>If you’re wondering why <code>ApplicativeAsk</code> has an <code>Applicative</code> field instead of just extending from <code>Applicative</code>, that is to avoid implicit ambiguities that arise from having multiple subclasses of a given type (here <code>Applicative</code>) in scope implicitly. So in this case we favor composition over inheritance as otherwise, we could not e.g. use <code>Monad</code> together with <code>ApplicativeAsk</code>.</p>\n</blockquote>\n<p>なので、基本的には<code>implicit</code>の衝突を回避する目的、ということでいいのだと思う。</p>\n<p>ところでcats-mtlのこのあとの例で、<code>implicit</code>で<code>MonadState</code>と<code>MonadError</code>しか取ってないのに<code>Monad</code>のメソッドが使えてる感じがする例があるのだけど、これはどういうことなんだろう？<br>\nどこから<code>Monad</code>のインスタンスを持って来てるんだ？</p>\n<p>あとDotty (Scala 3)の<code>given</code>と<code>delegate</code>もちょっと関係あるのかな、とか思ってるけど、その辺はよく分からない。<br>\n誰か詳しい人教えて。</p>\n<h2>その他気になる話</h2>\n<p>Typelevel.scala | A tale on Semirings: <a href=\"https://typelevel.org/blog/2018/11/02/semirings.html\">https://typelevel.org/blog/2018/11/02/semirings.html</a></p>\n<p>これが気になっている。あとでちゃんと読もう。</p>","fields":{"date":"2019-07-26"},"frontmatter":{"title":"ミリシタ折り返し"},"excerpt":"やったこと ミリシタ 折り返し。早いなと思ったら一日短いらしい。 とりあえず10万ptまで稼いだけど、うーん。 Scala関連 型クラスの制約のエンコード方法について ScalaでHaskellの型クラスの制約(Eq a => Ord aみたいなの)を表現するときに、Scala…"},"prev":null,"next":{"fields":{"date":"2019-07-25","slug":"/post/2019-07-25-diary/"},"frontmatter":{"title":"一段落"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/post/2019-07-26-diary/","prevSlug":null,"nextSlug":"/post/2019-07-25-diary/"}}}